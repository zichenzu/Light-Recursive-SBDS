#include <gecode/int/branch.hh>#include <gecode/int.hh>namespace Gecode{ 	//index_class	class Index_class{		public: 			int index;			int val;			~Index_class(){};			Index_class(int _index,int _val){index=_index;val=_val;};					  };	//symmetry class	class SBDS_Sym  {		private:			Space& _home;		public:			int _nSym;			IntArgs _nSymR;			int dosize;			BoolVarArray _symvars;			~SBDS_Sym() {} ;			Space& getManager() {return _home;};			int getNSym() {return _nSym;};			BoolVarArray getVars() {return _symvars;};		   			void symGoal(ViewArray<Int::IntView>& vars, int index, int val );//-----------------------------this is the normal SBDS adds conditional contrains			SBDS_Sym(Space& home, int nSym,int var_n,int dosize) ;			void SymAdjust(  ViewArray<Int::IntView>& vars, int index, int val) ;		   			SBDS_Sym(Space& home, SBDS_Sym OldSym) ;	};	void notq(Space& home, ViewArray<Int::IntView> vars, Int::BoolView b, int pos, int val);	typedef Index_class (*SymmetryFunction)(int ,int,int);	SymmetryFunction _symmetries;	extern SBDS_Sym *Sym;	extern IntArgs t_myindex,t_myval,my_record;	extern int r_my;	void symGoal(Space& _home,ViewArray<Int::IntView>& vars, int index, int val) {	 		// special for IntVars but could be generalised		if (Sym->_nSym == 0) { return ;} // i.e. no goal 							   // better way to return Truth?		else { 			 			int i = 0; 			Index_class k=(*_symmetries)(Sym->_nSymR[i],index,val);			 			  				 			  			for (; i < Sym->_nSym; i++) 	 			{  	if(Sym->_symvars[i].zero())      continue;				k=(*_symmetries)(Sym->_nSymR[i],index,val); 								if(Sym->_symvars[i].one()&&my_record[k.index*Sym->dosize+k.val]!=-1)				{   										t_myindex[r_my]=k.index;					t_myval[r_my++]=k.val;my_record[k.index*Sym->dosize+k.val]=-1;					symGoal(_home,vars,k.index,k.val);				}				else if(!Sym->_symvars[i].one())					notq(_home,vars,Sym->_symvars[i],k.index,k.val);					//rel(_home,(!Sym->_symvars[i]||(vars[k.index]!=k.val)));			}											  					 		}	  };					template<class View>	 class notEqual : public Propagator {	 protected: 		Int::BoolView b;		int pos; 		ViewArray<View> x;		int val;	 public: 		// posting		notEqual(Space& home, ViewArray<View> _x, Int::BoolView _b,int _pos, int _val) : Propagator(home), x(_x),b(_b), pos(_pos), val(_val) {			x[pos].subscribe(home,*this,Int::PC_INT_DOM);			b.subscribe(home,*this,Int::PC_BOOL_VAL);		} 		static ExecStatus post(Space& home, ViewArray<View> x, Int::BoolView b, int pos, int val) {			(void) new (home) notEqual(home,x, b, pos,val); 			return ES_OK; 		} 		// disposal 		virtual size_t dispose(Space& home) {			x[pos].cancel(home,*this,Int::PC_INT_DOM);			b.cancel(home,*this,Int::PC_BOOL_VAL);			(void) Propagator::dispose(home);			return sizeof(*this); 		} 		// copying		notEqual(Space& home, bool share, notEqual& p) : Propagator(home,share,p),pos(p.pos),val(p.val) {			x.update(home,share,p.x); 			b.update(home,share,p.b); 					} 		virtual Propagator* copy(Space& home, bool share) {			return new (home) notEqual(home,share,*this); 		} 		// cost computation 		virtual PropCost cost(const Space&, const ModEventDelta&) const {			return PropCost::binary(PropCost::LO); 		} 		// propagation 		virtual ExecStatus propagate(Space& home, const ModEventDelta&) {			 			if(b.zero()||!x[pos].in(val)) return home.ES_SUBSUMED(*this);			if(b.one()) 			{				GECODE_ME_CHECK(x[pos].nq(home,val));				//post more symmetry breaking constraints				 				symGoal(home,x,pos, val);							return home.ES_SUBSUMED(*this); 			}			if(x[pos].in(val)&&x[pos].assigned())			{				GECODE_ME_CHECK(b.zero(home));				return home.ES_SUBSUMED(*this); 			}			return ES_FIX;		} 	 };	void notq(Space& home, ViewArray<Int::IntView> x, Int::BoolView b, int pos, int val) { 		// constraint post function 		if (notEqual<Int::IntView>::post(home,x,b,pos,val)!= ES_OK)			home.fail(); 	} 	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	//////////////////////////////////////boolvar constraint////////////////////////////////////////////////////////////////////	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////					template<class View>	 class boolExp : public Propagator {	 protected: 		Int::BoolView b1;		Int::BoolView b2;		int pos; 		ViewArray<View> x;		int val;	 	 public: 		// posting		boolExp(Space& home, ViewArray<View>& _x, Int::BoolView _b1,Int::BoolView _b2,int _pos, int _val) : Propagator(home), x(_x),b1(_b1),b2(_b2), pos(_pos), val(_val) {			x[pos].subscribe(home,*this,Int::PC_INT_DOM);			b1.subscribe(home,*this,Int::PC_BOOL_VAL);			b2.subscribe(home,*this,Int::PC_BOOL_VAL);		} 		static ExecStatus post(Space& home, ViewArray<View>& x, Int::BoolView b1,Int::BoolView b2, int pos, int val) {			(void) new (home) boolExp(home,x, b1,b2, pos,val); 			return ES_OK; 		} 		// disposal 		virtual size_t dispose(Space& home) {			x[pos].cancel(home,*this,Int::PC_INT_DOM);			b1.cancel(home,*this,Int::PC_BOOL_VAL);			b2.cancel(home,*this,Int::PC_BOOL_VAL);			(void) Propagator::dispose(home);			return sizeof(*this); 		} 		// copying		boolExp(Space& home, bool share, boolExp& p) : Propagator(home,share,p),pos(p.pos),val(p.val)  {			x.update(home,share,p.x); 			b1.update(home,share,p.b1); 			b2.update(home,share,p.b2); 					} 		virtual Propagator* copy(Space& home, bool share) {			return new (home) boolExp(home,share,*this); 		} 		// cost computation 		virtual PropCost cost(const Space&, const ModEventDelta&) const {			return PropCost::binary(PropCost::LO); 		} 		// propagation 		virtual ExecStatus propagate(Space& home, const ModEventDelta&) {	 			if(b2.zero()||!x[pos].in(val))			{				GECODE_ME_CHECK(b1.zero(home));				return home.ES_SUBSUMED(*this); 			}			if(b2.one()&&x[pos].assigned()&&x[pos].in(val))			{				GECODE_ME_CHECK(b1.one(home));				return home.ES_SUBSUMED(*this); 			}			if(b1.one())			{				GECODE_ME_CHECK(b2.one(home));				GECODE_ME_CHECK(x[pos].eq(home,val));							return home.ES_SUBSUMED(*this); 			}			if(b1.zero())			{				if(b2.one())				{					GECODE_ME_CHECK(x[pos].nq(home,val));				 					//post more symmetry breaking constraints					symGoal(home,x,pos, val);						return home.ES_SUBSUMED(*this);				}				else if(x[pos].assigned()&&x[pos].in(val))				{					GECODE_ME_CHECK(b2.zero(home));					return home.ES_SUBSUMED(*this); 				}			}									return ES_FIX;		} 	 };	template<class View>	void boolEp(Space& home, ViewArray<View>& x, BoolVar b1, BoolVar b2, int pos, int val) { 		// constraint post function 		if (boolExp<View>::post(home,x,b1,b2,pos,val)!= ES_OK)			home.fail(); 	} }